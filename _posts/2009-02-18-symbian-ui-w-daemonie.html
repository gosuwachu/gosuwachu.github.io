---
layout: post
title: 'Symbian: UI w demonie'
date: 2009-02-18 17:12:56.000000000 +00:00
categories:
- Blog
tags:
- c++
- ceikonenv
- daemon
- Symbian
- ui
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  wpb_post_views_count: '340'
author:
  login: admin
  email: wach.piotrek@gmail.com
  display_name: Piotr Wach
  first_name: Piotr
  last_name: Wach
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Demon, czyli zwykła aplikacja, tworzona bez pomocy klasy CAknApplication, pozbawiona jest UI. Ta cecha sprawia, że może działać w tle niezauważalnie dla użytkownika. Zazwyczaj dostarcza pewnych usług innym programom(działając jako serwer) lub użytkownikowi. Tak jest na przykład ze wszystkimi serwerami działającymi w Symbianie, a do których dostęp odbywa się za pomocą klas R*(resoruce). Są to np. RFile, RFs, itp.</p>
<p>Czasem jednak potrzebujemy, aby aplikacja działająca w tle mogła wyświetlać na ekranie pewne informacje w formie bardziej skomplikowanej niż 'global note'. Ponieważ na starcie tworzenia aplikacji zrezygnowaliśmy z symbianowego frameworka, który inicjuje nam UI, musimy zrobić to sami. Można zapytać dlaczego po prostu nie użyć frameworka? Ponieważ mamy zbyt mały wpływ na proces uruchamiania się aplikacji, a przez to nie jesteśmy w stanie zapobiec np. pojawieniu się okna aplikacji.</p>
<p>Przykładem aplikacji działającej w tle i potrzebującej możliwości wyświetlania czegoś na ekranie jest aplikacja wyświetlająca zdjęcie osoby do której dzwonimy.</p>
<p>Przyjrzyjmy się poniższemu kawałkowi kodu:</p>
<p><!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow:auto;width:auto;color:black;background:white;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><span style="color: #408080; font-style: italic">// potrzebujemy obiektu klasy odpowiedzialnej za kontrolki i interakcje z użytkownikiem</span>
<span style="color: #008000; font-weight: bold">struct</span> CApplicationUI <span style="color: #666666">:</span> <span style="color: #008000; font-weight: bold">public</span> CEikAppUi
<span style="color: #408080; font-style: italic">// nie mamy żadnych plików zasobów</span>
{ 
	<span style="color: #B00040">void</span> ConstructL() 
	{	
		CEikAppUi<span style="color: #666666">::</span>BaseConstructL(ENonStandardResourceFile); 
	} 
};

<span style="color: #408080; font-style: italic">// początek wykonania programu</span>
GLDEF_C TInt E32Main()
{
	<span style="color: #408080; font-style: italic">// tworzymy jeden obiekt zarządzający interfejsem użytkownika</span>
	<span style="color: #408080; font-style: italic">// (nie mamy jeszcze CleanupStacka wiec nie możemy uzyć &#39;placement new&#39;)</span>
	CEikonEnv<span style="color: #666666">*</span> coe <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> CEikonEnv;

	<span style="color: #408080; font-style: italic">// EFalse oznacza, że nasza aplikacja nie potrzebuje w tym momencie focusa</span>
	TRAPD(error, coe<span style="color: #666666">-&gt;</span>ConstructL(EFalse));
	<span style="color: #008000; font-weight: bold">if</span>(error <span style="color: #666666">!=</span> KErrNone)
		<span style="color: #008000; font-weight: bold">return</span> KErrNone;
	coe<span style="color: #666666">-&gt;</span>SetAutoForwarding(ETrue);

	<span style="color: #408080; font-style: italic">// musimy stworzyć taki obiekt, w przeciwnym razie aplikacja rzuci panic,</span>
	<span style="color: #408080; font-style: italic">// wskaźnik do tego obiektu jest używany w którymś miejscu frameworka</span>
	CApplicationUI<span style="color: #666666">*</span> applicationUI <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> (ELeave) CApplicationUI;

	TRAP(error, applicationUI<span style="color: #666666">-&gt;</span>ConstructL());
	<span style="color: #008000; font-weight: bold">if</span>(error <span style="color: #666666">!=</span> KErrNone)
		<span style="color: #008000; font-weight: bold">return</span> KErrNone;

	<span style="color: #408080; font-style: italic">// musimy wyłączyć sprawdzanie leaków, aby wyjście z aplikacji było czyste</span>
	coe<span style="color: #666666">-&gt;</span>DisableExitChecks(ETrue);

	<span style="color: #408080; font-style: italic">// uruchamiamy aplikację</span>
	TRAP(error, coe<span style="color: #666666">-&gt;</span>ExecuteD());
	<span style="color: #008000; font-weight: bold">if</span>(error <span style="color: #666666">!=</span> KErrNone)
		<span style="color: #008000; font-weight: bold">return</span> KErrNone;

	<span style="color: #408080; font-style: italic">// po zakończeniu czyścimy po sobie zainicjowane obiekty</span>
	<span style="color: #408080; font-style: italic">// ta funkcja robi wszystko za nas</span>
	coe<span style="color: #666666">-&gt;</span>DestroyEnvironment();

	<span style="color: #008000; font-weight: bold">return</span> KErrNone;
}
</pre>
</div>
<p>Jak widać rozwiązanie nie jest bardzo skomplikowane, a Symbian nie taki straszny jak go malują ;) (swoją droga dojście do tego zajęło mi kiedyś sporo czasu ;p)</p>
<p>Obecnie jestem w trakcie tworzenia aplikacji korzystającej z tej metody. Ma wyświetlać pełnoekranowe zdjęcie osoby dzwoniącej. Po zakończeniu rozmowy będzie możliwość dodania osoby do książki. Czekam na wasze wsparcie :) Co myślicie na temat notek o programowaniu w Symbianie? Powinienem mówić bardziej o podstawach czy raczej o takich ciekawostkach jak powyższa?</p>
<p>Pozdrawiam, do następnego odcinka. Może skrobne coś o kilku genialnych aplikacjach czyniących życie łatwiejszym :)</p>
